diff -uNr Bumblebee.org/conf/bumblebee.conf.in Bumblebee/conf/bumblebee.conf.in
--- Bumblebee.org/conf/bumblebee.conf.in	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/conf/bumblebee.conf.in	2018-03-20 08:02:23.365503964 +0800
@@ -22,6 +22,8 @@
 Driver=@CONF_DRIVER@
 # Directory with a dummy config file to pass as a -configdir to secondary X
 XorgConfDir=@XCONFDDIR@
+# Xorg binary to run
+XorgBinary=@CONF_XORG_BINARY@
 
 ## Client options. Will take effect on the next optirun executed.
 [optirun]
diff -uNr Bumblebee.org/configure.ac Bumblebee/configure.ac
--- Bumblebee.org/configure.ac	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/configure.ac	2018-03-20 08:02:26.069519409 +0800
@@ -32,6 +32,16 @@
 AC_DEFINE_SUBST(CONF_VGLCOMPRESS, "proxy", [vglclient transport method])
 AC_DEFINE_SUBST(CONF_TURNOFFATEXIT, "false", [state of card when shutting off daemon])
 
+# OpenSUSE: /usr/bin/X -> /var/lib/X11/X -> /usr/bin/Xorg
+# Fedora, Arch Linux: /usr/bin/X -> /usr/bin/Xorg
+# Ubuntu: /usr/bin/X is a custom binary doing authorization and then executes
+#         /etc/X11/X -> /usr/bin/Xorg
+AC_DEFINE_CONF(CONF_XORG_BINARY, [Xorg binary to run], [
+if test "x" = "x$CONF_XORG_BINARY"; then
+	CONF_XORG_BINARY=Xorg
+fi
+])
+
 AC_DEFINE_CONF(CONF_BRIDGE, [optirun display/render bridge, valid values are auto (default), primus and virtualgl], [
 case $CONF_BRIDGE in
 auto|primus|virtualgl) ;;
@@ -122,6 +132,7 @@
 # Checks for header files.
 PKG_CHECK_MODULES([x11], [x11])
 PKG_CHECK_MODULES([glib], [glib-2.0])
+PKG_CHECK_MODULES([kmod], [libkmod])
 AS_IF([test "x$with_pidfile" != xno], [
 		PKG_CHECK_MODULES([libbsd], [libbsd >= 0.2.0])
 		PKG_CHECK_EXISTS([libbsd = 0.2.0], [AC_DEFINE(HAVE_LIBBSD_020)])
diff -uNr Bumblebee.org/Makefile.am Bumblebee/Makefile.am
--- Bumblebee.org/Makefile.am	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/Makefile.am	2018-03-20 08:02:26.069519409 +0800
@@ -10,7 +10,7 @@
 		-DCONF_XORG='"$(bumblebeedconfdir)/xorg.conf.DRIVER"' \
 		-DCONF_XORG_DIR='"$(bumblebeedconfdir)/xorg.conf.d"'
 AM_CFLAGS = ${regular_CFLAGS} \
-		${x11_CFLAGS} ${libbsd_CFLAGS} ${glib_CFLAGS} \
+		${x11_CFLAGS} ${libbsd_CFLAGS} ${glib_CFLAGS} ${kmod_CFLAGS} \
 		-Wextra -funsigned-char -DGITVERSION='"${GITVERSION}"'
 
 noinst_SCRIPTS = scripts/systemd/bumblebeed.service \
@@ -49,13 +49,13 @@
 bin_PROGRAMS = bin/optirun
 
 bin_optirun_SOURCES = src/module.c src/bbconfig.c src/bblogger.c src/bbrun.c \
-	src/bbsocket.c src/driver.c src/optirun.c src/bbsocketclient.c
-bin_optirun_LDADD = ${glib_LIBS} -lrt
+	src/bbsocket.c src/optirun.c src/bbsocketclient.c
+bin_optirun_LDADD = ${glib_LIBS} ${kmod_LIBS} -lrt
 bin_bumblebeed_SOURCES = src/pci.c src/bbconfig.c src/bblogger.c src/bbrun.c \
 	src/bbsocket.c src/module.c src/bbsecondary.c src/switch/switching.c \
 	src/switch/sw_bbswitch.c src/switch/sw_switcheroo.c \
 	src/driver.c src/bumblebeed.c
-bin_bumblebeed_LDADD = ${x11_LIBS} ${libbsd_LIBS} ${glib_LIBS} -lrt
+bin_bumblebeed_LDADD = ${x11_LIBS} ${libbsd_LIBS} ${glib_LIBS} ${kmod_LIBS} -lrt
 
 dist_doc_DATA = $(relnotes) README.markdown
 bumblebeedconf_DATA = conf/bumblebee.conf conf/xorg.conf.nouveau conf/xorg.conf.nvidia
@@ -70,6 +70,7 @@
 
 do_subst = sed -e 's|[@]GITVERSION[@]|$(GITVERSION)|g' \
 	-e 's|[@]CONF_XDISP[@]|$(CONF_XDISP)|g' \
+	-e 's|[@]CONF_XORG_BINARY[@]|$(CONF_XORG_BINARY)|g' \
 	-e 's|[@]CONF_SOCKPATH[@]|$(CONF_SOCKPATH)|g' \
 	-e 's|[@]CONF_GID[@]|$(CONF_GID)|g' \
 	-e 's|[@]CONF_PM_METHOD[@]|$(CONF_PM_METHOD)|g' \
diff -uNr Bumblebee.org/README.markdown Bumblebee/README.markdown
--- Bumblebee.org/README.markdown	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/README.markdown	2018-03-20 08:02:26.069519409 +0800
@@ -19,6 +19,7 @@
 - pkg-config
 - glib-2.0 and development headers
 - libx11 and development headers
+- libkmod2 and development headers
 - libbsd and development headers (if pidfile support is enabled, default yes)
 - help2man (optional, it is needed for building manual pages)
 
diff -uNr Bumblebee.org/src/bbconfig.c Bumblebee/src/bbconfig.c
--- Bumblebee.org/src/bbconfig.c	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/bbconfig.c	2018-03-20 08:02:26.069519409 +0800
@@ -251,12 +251,6 @@
  */
 static int bbconfig_parse_common(int opt, char *value) {
   switch (opt) {
-    case 'q'://quiet mode
-      bb_status.verbosity = VERB_NONE;
-      break;
-    case OPT_DEBUG://debug mode
-      bb_status.verbosity = VERB_ALL;
-      break;
     case 'd'://X display number
       set_string_value(&bb_config.x_display, value);
       break;
@@ -307,6 +301,12 @@
             bb_status.verbosity++;
           }
           break;
+        case 'q'://quiet mode
+          bb_status.verbosity = VERB_NONE;
+          break;
+        case OPT_DEBUG://debug mode
+          bb_status.verbosity = VERB_ALL;
+          break;
         case 's': /* Unix socket to use for communication */
           set_string_value(&bb_config.socket_path, optarg);
           break;
@@ -425,6 +425,10 @@
   if (g_key_file_has_key(bbcfg, section, key, NULL)) {
     free_and_set_value(&bb_config.x_conf_dir, g_key_file_get_string(bbcfg, section, key, NULL));
   }
+  key = "XorgBinary";
+  if (g_key_file_has_key(bbcfg, section, key, NULL)) {
+    free_and_set_value(&bb_config.xorg_binary, g_key_file_get_string(bbcfg, section, key, NULL));
+  }
   return bbcfg;
 }
 
@@ -517,6 +521,7 @@
   set_string_value(&bb_config.gid_name, CONF_GID);
   set_string_value(&bb_config.x_conf_file, CONF_XORG);
   set_string_value(&bb_config.x_conf_dir, CONF_XORG_DIR);
+  set_string_value(&bb_config.xorg_binary, CONF_XORG_BINARY);
   set_string_value(&bb_config.optirun_bridge, CONF_BRIDGE);
   set_string_value(&bb_config.primus_ld_path, CONF_PRIMUS_LD_PATH);
   set_string_value(&bb_config.vgl_compress, CONF_VGLCOMPRESS);
@@ -550,6 +555,7 @@
 #endif
     bb_log(LOG_DEBUG, " xorg.conf file: %s\n", bb_config.x_conf_file);
     bb_log(LOG_DEBUG, " xorg.conf.d dir: %s\n", bb_config.x_conf_dir);
+    bb_log(LOG_DEBUG, " Xorg binary: %s\n", bb_config.xorg_binary);
     bb_log(LOG_DEBUG, " ModulePath: %s\n", bb_config.mod_path);
     bb_log(LOG_DEBUG, " GID name: %s\n", bb_config.gid_name);
     bb_log(LOG_DEBUG, " Power method: %s\n",
diff -uNr Bumblebee.org/src/bbconfig.h Bumblebee/src/bbconfig.h
--- Bumblebee.org/src/bbconfig.h	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/bbconfig.h	2018-03-20 08:02:26.069519409 +0800
@@ -26,6 +26,7 @@
 #include <unistd.h> //for pid_t
 #include <limits.h> //for CHAR_MAX
 #include <glib.h>
+#include <libkmod.h>
 
 /* Daemon states */
 #define BB_DAEMON 1
@@ -118,10 +119,12 @@
     int x_pipe[2];//pipes for reading/writing output from X's stdout/stderr
     gboolean use_syslog;
     char *program_name;
+    struct kmod_ctx *kmod_ctx;
 };
 
 /* Structure containing the configuration. */
 struct bb_config_struct {
+    char * xorg_binary; /// Xorg binary to run.
     char * x_display; /// X display number to use.
     char * x_conf_file; /// Path to the X configuration file.
     char * x_conf_dir; /// Path to the dummy X configuration directory.
diff -uNr Bumblebee.org/src/bblogger.c Bumblebee/src/bblogger.c
--- Bumblebee.org/src/bblogger.c	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/bblogger.c	2018-03-20 08:02:26.069519409 +0800
@@ -225,7 +225,7 @@
         /* line / buffer is full, process the remaining buffer the next round */
         repeat = 1;
       }
-    }else{
+    } else {
       if (r == 0 || (errno != EAGAIN && r == -1)){
         /* the pipe is closed/invalid. Clean up. */
         if (bb_status.x_pipe[0] != -1){close(bb_status.x_pipe[0]); bb_status.x_pipe[0] = -1;}
@@ -254,5 +254,5 @@
         memmove(x_output_buffer, next_part, x_buffer_pos);
       }
     }
-  }while(repeat);
+  }while (repeat);
 }/* check_xorg_pipe */
diff -uNr Bumblebee.org/src/bblogger.c.orig Bumblebee/src/bblogger.c.orig
--- Bumblebee.org/src/bblogger.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ Bumblebee/src/bblogger.c.orig	2018-03-20 07:43:06.000000000 +0800
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2011-2013, The Bumblebee Project
+ * Author: Joaquín Ignacio Aramendía samsagax@gmail.com
+ *
+ * This file is part of Bumblebee.
+ *
+ * Bumblebee is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Bumblebee is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Bumblebee. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * bblogger.c: loggin functions for bumblebee daemon and client
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <time.h>
+#include "bblogger.h"
+#include "bbconfig.h"
+
+char x_output_buffer[512]; /* Xorg output buffer */
+int x_buffer_pos = 0;/* Xorg output buffer position */
+
+
+/**
+ * Initialize log capabilities. Return 0 on success
+ */
+int bb_init_log(void) {
+  /*  Open Logggin mechanism based on configuration */
+  if (bb_status.use_syslog) {
+    openlog(DAEMON_NAME, LOG_PID, LOG_DAEMON);
+  } else {
+  }
+  /*  Should end with no error by now */
+  return 0;
+}
+
+/**
+ * Log a message to the current log mechanism.
+ * Try to keep log messages less than 80 characters.
+ */
+void bb_log(int priority, char* msg_format, ...) {
+  switch (priority) {
+    case LOG_ERR:
+      if (bb_status.verbosity < VERB_ERR) {
+        return;
+      }
+      break;
+    case LOG_WARNING:
+      if (bb_status.verbosity < VERB_WARN) {
+        return;
+      }
+      break;
+    case LOG_NOTICE:
+      if (bb_status.verbosity < VERB_NOTICE) {
+        return;
+      }
+      break;
+    case LOG_INFO:
+      if (bb_status.verbosity < VERB_INFO) {
+        return;
+      }
+      break;
+    case LOG_DEBUG:
+      if (bb_status.verbosity < VERB_DEBUG) {
+        return;
+      }
+      break;
+    default:
+      /* unspecified log level, always log it unless verbosity is NONE */
+      if (bb_status.verbosity == VERB_NONE) {
+        return;
+      }
+      break;
+  }
+
+  va_list args;
+  va_start(args, msg_format);
+  if (bb_status.use_syslog) {
+    vsyslog(priority, msg_format, args);
+  } else {
+    char* fullmsg_fmt = malloc(BUFFER_SIZE + 8);
+    struct timespec tp;
+    clock_gettime(CLOCK_MONOTONIC, &tp);
+    switch (priority) {
+      case LOG_ERR:
+        fullmsg_fmt = strcpy(fullmsg_fmt, "[ERROR]");
+        break;
+      case LOG_DEBUG:
+        fullmsg_fmt = strcpy(fullmsg_fmt, "[DEBUG]");
+        break;
+      case LOG_WARNING:
+        fullmsg_fmt = strcpy(fullmsg_fmt, "[WARN]");
+        break;
+      default:
+        fullmsg_fmt = strcpy(fullmsg_fmt, "[INFO]");
+    }
+    fullmsg_fmt = strncat(fullmsg_fmt, msg_format, BUFFER_SIZE);
+    fprintf(stderr, "[%5llu.%06lu] ", (long long)tp.tv_sec, tp.tv_nsec / 1000);
+    vfprintf(stderr, fullmsg_fmt, args);
+    free(fullmsg_fmt);
+  }
+  va_end(args);
+}
+
+/**
+ * Close logging mechanism
+ */
+void bb_closelog(void) {
+  if (bb_status.use_syslog) {
+    closelog();
+  }
+}
+
+/** Parses a single null-terminated string of Xorg output.
+ * Will call bb_log appropiately.
+ */
+static void parse_xorg_output(char * string){
+  int prio = LOG_DEBUG;/* most lines are debug messages */
+  char * valid = 0; /* Helper for finding correct ConnectedMonitor setting */
+  char * valid_end = 0; /* Helper for finding correct ConnectedMonitor setting */
+  /* message to be logged with set_bb_error */
+  char error_buffer[strlen("[XORG] ") + sizeof (x_output_buffer)];
+
+  /* don't log an empty line or a line with a single whitespace */
+  if (string[0] == 0 || (string[1] == 0 && isspace(string[0]))) {
+    return;
+  }
+
+  /* Error lines are errors. */
+  if (strncmp(string, "(EE)", 4) == 0){
+    if (strstr(string, "Failed to load module \"kbd\"") ||
+            strstr(string, "No input driver matching")) {
+      /* non-fatal errors */
+      prio = LOG_DEBUG;
+    } else {
+      /* prefix with [XORG] */
+      snprintf(error_buffer, sizeof error_buffer, "[XORG] %s", string);
+      set_bb_error(error_buffer);//set as error
+      /* errors are handled seperately from the rest - return */
+      return;
+    }
+  }
+
+  /* Warning lines are warnings. */
+  if (strncmp(string, "(WW)", 4) == 0){
+    prio = LOG_WARNING;
+    /* recognize some of the less useful warnings, degrade them to LOG_DEBUG level. */
+    if (
+            /* nouveau: warning about no outputs being found connected */
+            strstr(string, "trying again") ||
+            /* nouveau: warning for set resolution with no screen attached */
+            strstr(string, "initial framebuffer") ||
+            /* X: no keyboard/mouse warning */
+            strstr(string, "looking for one") ||
+            /* nvidia: cannot read EDID warning */
+            strstr(string, "EDID") ||
+            /* fonts directory that cannot be found */
+            strstr(string, "The directory \"") ||
+            /* kbd module that is trying to get loaded */
+            strstr(string, "couldn't open module kbd") ||
+            /* we're not interested in input drivers */
+            strstr(string, "No input driver matching")) {
+      prio = LOG_DEBUG;
+    } else if (strstr(string, "valid display devices are")) {
+      /* Recognize nvidia complaining about ConnectedMonitor setting */
+      valid = strchr(string, '\'');//find the '-character
+      if (valid){
+        char last_chr = 0;
+        valid_end = ++valid;/* advance valid one character, start searching for end */
+        while (valid_end[0] != 0){
+          last_chr = valid_end[0];
+          if (last_chr == '\'' || last_chr == ',' || last_chr == ' ') {
+            valid_end[0] = 0;
+            break;
+          }
+          valid_end++;
+        }
+        set_bb_error(0); /* Clear error message, we want to override it even though it is not first */
+        snprintf(error_buffer, sizeof error_buffer, "You need to change the"
+                " ConnectedMonitor setting in %s to %s",
+                bb_config.x_conf_file, valid);
+        set_bb_error(error_buffer);//set as error
+        /* Restore the string for logging purposes */
+        valid_end[0] = last_chr;
+      }
+    }
+  }
+  
+  /* do the actual logging */
+  bb_log(prio, "[XORG] %s\n", string);
+}
+
+/** Will check the xorg output pipe and parse any waiting messages.
+ * Doesn't take any parameters and doesn't return anything.
+ */
+void check_xorg_pipe(void){
+  if (bb_status.x_pipe[0] == -1){return;}
+  int repeat;
+
+  do{
+    repeat = 0;
+    /* attempt to read at most the entire buffer full. */
+    int r = read(bb_status.x_pipe[0], x_output_buffer + x_buffer_pos,
+            sizeof (x_output_buffer) - x_buffer_pos - 1);
+    if (r > 0){
+      x_buffer_pos += r;
+      /* append a null byte to close the string */
+      x_output_buffer[x_buffer_pos] = 0;
+      if (x_buffer_pos == sizeof (x_output_buffer) - 1) {
+        /* line / buffer is full, process the remaining buffer the next round */
+        repeat = 1;
+      }
+    }else{
+      if (r == 0 || (errno != EAGAIN && r == -1)){
+        /* the pipe is closed/invalid. Clean up. */
+        if (bb_status.x_pipe[0] != -1){close(bb_status.x_pipe[0]); bb_status.x_pipe[0] = -1;}
+        if (bb_status.x_pipe[1] != -1){close(bb_status.x_pipe[1]); bb_status.x_pipe[1] = -1;}
+      }
+    }
+    /* while x_buffer_pos>0 and a \n is in the buffer, parse.
+     * if buffer is full, parse also. */
+    while (x_buffer_pos > 0){
+      char * foundnewline = strchr(x_output_buffer, '\n');
+      if (!foundnewline || foundnewline-x_output_buffer > x_buffer_pos){
+        /* cancel search if no newline, try again later
+         * except if buffer is full, then parse */
+        if (x_buffer_pos == sizeof (x_output_buffer) - 1) {
+          parse_xorg_output(x_output_buffer);
+          x_buffer_pos = 0;
+        }
+        break;
+      }
+      foundnewline[0] = 0;/* convert newline to null byte */
+      parse_xorg_output(x_output_buffer);/* parse the line */
+      char *next_part = foundnewline + 1; /* begin of next line */
+      int size = next_part - x_output_buffer;
+      x_buffer_pos -= size;/* cut the parsed part from the buffer size */
+      if (x_buffer_pos > 0){/* move the unparsed part left, if any */
+        memmove(x_output_buffer, next_part, x_buffer_pos);
+      }
+    }
+  }while(repeat);
+}/* check_xorg_pipe */
diff -uNr Bumblebee.org/src/bbsecondary.c Bumblebee/src/bbsecondary.c
--- Bumblebee.org/src/bbsecondary.c	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/bbsecondary.c	2018-03-20 08:02:23.365503964 +0800
@@ -146,7 +146,7 @@
 
     bb_log(LOG_INFO, "Starting X server on display %s.\n", bb_config.x_display);
     char *x_argv[] = {
-      XORG_BINARY,
+      bb_config.xorg_binary,
       bb_config.x_display,
       "-config", x_conf_file,
       "-configdir", bb_config.x_conf_dir,
@@ -158,6 +158,12 @@
       "-modulepath", bb_config.mod_path, // keep last
       NULL
     };
+    char **argvp;
+    bb_log(LOG_DEBUG, "X server command line:");
+    for (argvp = x_argv; argvp && *argvp; argvp++) {
+	    bb_log(LOG_DEBUG, " %s", *argvp);
+    }
+    bb_log(LOG_DEBUG, "\n");
     enum {n_x_args = sizeof(x_argv) / sizeof(x_argv[0])};
     if (!*bb_config.mod_path) {
       x_argv[n_x_args - 3] = 0; //remove -modulepath if not set
diff -uNr Bumblebee.org/src/bbsecondary.h Bumblebee/src/bbsecondary.h
--- Bumblebee.org/src/bbsecondary.h	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/bbsecondary.h	2018-03-20 08:02:23.365503964 +0800
@@ -20,14 +20,6 @@
  */
 #pragma once
 
-/**
- * OpenSUSE: /usr/bin/X -> /var/lib/X11/X -> /usr/bin/Xorg
- * Fedora, Arch Linux: /usr/bin/X -> /usr/bin/Xorg
- * Ubuntu: /usr/bin/X is a custom binary doing authorization and then executes
- *         /etc/X11/X -> /usr/bin/Xorg
- */
-#define XORG_BINARY "Xorg"
-
 /* PCI Bus ID of the discrete video card */
 struct pci_bus_id *pci_bus_id_discrete;
 
diff -uNr Bumblebee.org/src/bumblebeed.c Bumblebee/src/bumblebeed.c
--- Bumblebee.org/src/bumblebeed.c	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/bumblebeed.c	2018-03-20 08:02:26.069519409 +0800
@@ -34,6 +34,7 @@
 #include <string.h>
 #include <errno.h>
 #include <getopt.h>
+#include <libkmod.h>
 #ifdef WITH_PIDFILE
 #ifdef HAVE_LIBBSD_020
 #include <libutil.h>
@@ -488,6 +489,14 @@
 
   free(pci_id_igd);
 
+  // kmod context have to be available for driver detection
+  bb_status.kmod_ctx = kmod_new(NULL, NULL);
+  if (bb_status.kmod_ctx == NULL) {
+    bb_log(LOG_ERR, "kmod_new() failed!\n");
+    bb_closelog();
+    exit(EXIT_FAILURE);
+  }
+
   GKeyFile *bbcfg = bbconfig_parse_conf();
   bbconfig_parse_opts(argc, argv, PARSE_STAGE_DRIVER);
   driver_detect();
@@ -500,6 +509,7 @@
 
   /* dump the config after detecting the driver */
   config_dump();
+
   if (config_validate() != 0) {
     return (EXIT_FAILURE);
   }
@@ -572,5 +582,7 @@
   //close X pipe, if any parts of it are open still
   if (bb_status.x_pipe[0] != -1){close(bb_status.x_pipe[0]); bb_status.x_pipe[0] = -1;}
   if (bb_status.x_pipe[1] != -1){close(bb_status.x_pipe[1]); bb_status.x_pipe[1] = -1;}
+  //cleanup kmod context
+  kmod_unref(bb_status.kmod_ctx);
   return (EXIT_SUCCESS);
 }
diff -uNr Bumblebee.org/src/module.c Bumblebee/src/module.c
--- Bumblebee.org/src/module.c	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/module.c	2018-03-20 08:21:37.705643782 +0800
@@ -24,90 +24,151 @@
 #include <ctype.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <libkmod.h>
+#include <errno.h>
 #include "module.h"
 #include "bblogger.h"
 #include "bbrun.h"
 
 /**
  * Checks in /proc/modules whether a kernel module is loaded
+ * Checks whether a kernel module is loaded
  *
  * @param driver The name of the driver (not a filename)
  * @return 1 if the module is loaded, 0 otherwise
  */
 int module_is_loaded(char *driver) {
-  // use the same buffer length as lsmod
-  char buffer[4096];
-  FILE * bbs = fopen("/proc/modules", "r");
-  int ret = 0;
-  /* assume mod_len <= sizeof(buffer) */
-  int mod_len = strlen(driver);
-
-  if (bbs == 0) {//error opening, return -1
-    bb_log(LOG_DEBUG, "Couldn't open /proc/modules");
-    return -1;
-  }
-  while (fgets(buffer, sizeof(buffer), bbs)) {
-    /* match "module" with "module " and not "module-blah" */
-    if (!strncmp(buffer, driver, mod_len) && isspace(buffer[mod_len])) {
-      /* module is found */
-      ret = 1;
-      break;
-    }
+  struct kmod_module *mod;
+
+  err = kmod_module_new_from_name(bb_status.kmod_ctx, driver, &mod);
+  if (err < 0) {
+    bb_log(LOG_DEBUG, "kmod_module_new_from_name(%s) failed (err: %d).\n",
+      driver, err);
+    return 0;
   }
-  fclose(bbs);
-  return ret;
+
+  state = kmod_module_get_initstate(mod);
+  kmod_module_unref(mod);
+
+  return state == KMOD_MODULE_LIVE;
 }
 
 /**
  * Attempts to load a module. If the module has not been loaded after ten
  * seconds, give up
+ * Attempts to load a module.
  *
  * @param module_name The filename of the module to be loaded
  * @param driver The name of the driver to be loaded
  * @return 1 if the driver is succesfully loaded, 0 otherwise
  */
 int module_load(char *module_name, char *driver) {
+  int err = 0;
+  int flags = KMOD_PROBE_IGNORE_LOADED;
+  struct kmod_list *l, *list = NULL;
+
   if (module_is_loaded(driver) == 0) {
     /* the module has not loaded yet, try to load it */
-    bb_log(LOG_INFO, "Loading driver %s (module %s)\n", driver, module_name);
-    char *mod_argv[] = {
-      "modprobe",
-      module_name,
-      NULL
-    };
-    bb_run_fork_wait(mod_argv, 10);
-    if (module_is_loaded(driver) == 0) {
-      bb_log(LOG_ERR, "Module %s could not be loaded (timeout?)\n", module_name);
+    bb_log(LOG_INFO, "Loading driver '%s' (module '%s')\n", driver, module_name);
+    err = kmod_module_new_from_lookup(bb_status.kmod_ctx, module_name, &list);
+
+    if (err < 0) {
+      bb_log(LOG_DEBUG, "kmod_module_new_from_lookup(%s) failed (err: %d).\n",
+        module_name, err);
       return 0;
     }
+
+    if (list == NULL) {
+      bb_log(LOG_ERR, "Module '%s' not found.\n", module_name);
+      return 0;
+    }
+    kmod_list_foreach(l, list) {
+      struct kmod_module *mod = kmod_module_get_module(l);
+
+      bb_log(LOG_DEBUG, "Loading module '%s'.\n", kmod_module_get_name(mod));
+      err = kmod_module_probe_insert_module(mod, flags, NULL, NULL, NULL, 0);
+
+      if (err < 0) {
+        bb_log(LOG_DEBUG, "kmod_module_probe_insert_module(%s) failed (err: %d).\n",
+          kmod_module_get_name(mod), err);
+      }
+
+      kmod_module_unref(mod);
+
+      if (err < 0) {
+        break;
+      }
+    }
+
+    kmod_module_unref_list(list);
   }
-  return 1;
+
+  return err >= 0;
+
 }
 
 /**
- * Attempts to unload a module if loaded, for ten seconds before
- * giving up
+ * Unloads module and modules that are depending on this module.
+ *
+ * @param mod Reference to libkmod module
+ * @return 1 if the module is successfully unloaded, 0 otherwise
+ */
+int module_unload_recursive(struct kmod_module *mod) {
+  int err = 0, flags = 0, refcnt;
+  struct kmod_list *holders;
+
+  holders = kmod_module_get_holders(mod);
+  if (holders != NULL) {
+    struct kmod_list *itr;
+
+    kmod_list_foreach(itr, holders) {
+      struct kmod_module *hm = kmod_module_get_module(itr);
+      err = module_unload_recursive(hm);
+      kmod_module_unref(hm);
+
+      if (err < 0) {
+        break;
+      }
+    }
+    kmod_module_unref_list(holders);
+  }
+
+  refcnt = kmod_module_get_refcnt(mod);
+  if (refcnt == 0) {
+    bb_log(LOG_INFO, "Unloading module %s\n", kmod_module_get_name(mod));
+    err = kmod_module_remove_module(mod, flags);
+  } else {
+    bb_log(LOG_ERR, "Failed to unload module '%s' (ref count: %d).\n",
+      kmod_module_get_name(mod), refcnt);
+    err = 1;
+  }
+
+  return err == 0;
+}
+
+/**
+ * Attempts to unload a module if loaded.
  *
  * @param driver The name of the driver (not a filename)
  * @return 1 if the driver is succesfully unloaded, 0 otherwise
  */
 int module_unload(char *driver) {
+  int err;
+  struct kmod_module *mod;
+
   if (module_is_loaded(driver) == 1) {
-    int retries = 30;
-    bb_log(LOG_INFO, "Unloading %s driver\n", driver);
-    char *mod_argv[] = {
-      "rmmod",
-      driver,
-      NULL
-    };
-    bb_run_fork_wait(mod_argv, 10);
-    while (retries-- > 0 && module_is_loaded(driver) == 1) {
-      usleep(100000);
-    }
-    if (module_is_loaded(driver) == 1) {
-      bb_log(LOG_ERR, "Unloading %s driver timed out.\n", driver);
+    err = kmod_module_new_from_name(bb_status.kmod_ctx, driver, &mod);
+
+    if (err < 0) {
+      bb_log(LOG_DEBUG, "kmod_module_new_from_name(%s) failed (err: %d).\n",
+        driver, err);
+
       return 0;
     }
+    err = module_unload_recursive(mod);
+    kmod_module_unref(mod);
+
+    return err;
   }
   return 1;
 }
@@ -119,18 +180,17 @@
  * @return 1 if the module is available for loading, 0 otherwise
  */
 int module_is_available(char *module_name) {
-  /* HACK to support call from optirun */
-  char *modprobe_bin = "/sbin/modprobe";
-  if (access(modprobe_bin, X_OK)) {
-    /* if /sbin/modprobe is not found, pray that PATH contains it */
-    modprobe_bin = "modprobe";
-  }
-  char *mod_argv[] = {
-    modprobe_bin,
-    "--dry-run",
-    "--quiet",
-    module_name,
-    NULL
-  };
-  return bb_run_fork(mod_argv, 1) == EXIT_SUCCESS;
+  int err, available;
+  struct kmod_list *list = NULL;
+
+  err = kmod_module_new_from_lookup(bb_status.kmod_ctx, module_name, &list);
+
+  if (err < 0) {
+    bb_log(LOG_DEBUG, "kmod_module_new_from_lookup(%s) failed (err: %d).\n",
+      module_name, err);
+    return 0;
+  }
+  available = list != NULL;
+  kmod_module_unref_list(list);
+  return available;
 }
diff -uNr Bumblebee.org/src/optirun.c Bumblebee/src/optirun.c
--- Bumblebee.org/src/optirun.c	2018-03-20 07:43:06.000000000 +0800
+++ Bumblebee/src/optirun.c	2018-03-20 08:02:26.069519409 +0800
@@ -37,7 +37,6 @@
 #include "bbsocketclient.h"
 #include "bblogger.h"
 #include "bbrun.h"
-#include "driver.h"
 
 
 /**
