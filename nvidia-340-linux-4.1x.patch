diff -uNr kernel.orig/nv.c kernel/nv.c
--- kernel.orig/nv.c	2018-01-10 06:00:12.000000000 +0800
+++ kernel/nv.c	2019-09-24 10:14:33.387006856 +0800
@@ -1038,6 +1038,8 @@
 
     pci_unregister_driver(&nv_pci_driver);
 
+    nv_unregister_procfs();
+
 failed5:
     rm_shutdown_rm(sp);
 
diff -uNr kernel.orig/uvm/nvidia_uvm_lite.c kernel/uvm/nvidia_uvm_lite.c
--- kernel.orig/uvm/nvidia_uvm_lite.c	2018-01-10 06:00:12.000000000 +0800
+++ kernel/uvm/nvidia_uvm_lite.c	2019-09-24 10:14:36.155023495 +0800
@@ -30,6 +30,8 @@
 #include "nvidia_uvm_lite_counters.h"
 #include "ctrl2080mc.h"
 
+#include <linux/version.h>
+
 //
 // nvidia_uvm_lite.c
 // This file contains code that is specific to the UVM-Lite mode of operation.
@@ -689,9 +691,16 @@
 //         return SIGBUS.
 //      3. Otherwise, map in a page from the cache, and allow access.
 //
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+int _fault_common(struct vm_fault *vmf, unsigned long vaddr,
+#else
 int _fault_common(struct vm_area_struct *vma, unsigned long vaddr,
+#endif
                   struct page **ppage, unsigned vmfFlags)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+    struct vm_area_struct *vma = vmf->vma;
+#endif
     int retValue = VM_FAULT_SIGBUS;
     UvmCommitRecord *pRecord;
     DriverPrivate *pPriv;
@@ -818,7 +827,11 @@
 }
 
 #if defined(NV_VM_OPERATIONS_STRUCT_HAS_FAULT)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+int _fault(struct vm_fault *vmf)
+#else
 int _fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+#endif
 {
 #if defined(NV_VM_FAULT_HAS_ADDRESS)
     unsigned long vaddr = vmf->address;
@@ -828,7 +841,11 @@
     struct page *page = NULL;
     int retval;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+    retval = _fault_common(vmf, vaddr, &page, vmf->flags);
+#else
     retval = _fault_common(vma, vaddr, &page, vmf->flags);
+#endif
 
     vmf->page = page;
 
@@ -866,7 +883,11 @@
 // it's dealing with anonymous mapping (see handle_pte_fault).
 //
 #if defined(NV_VM_OPERATIONS_STRUCT_HAS_FAULT)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+int _sigbus_fault(struct vm_fault *vmf)
+#else
 int _sigbus_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+#endif
 {
     vmf->page = NULL;
     return VM_FAULT_SIGBUS;
